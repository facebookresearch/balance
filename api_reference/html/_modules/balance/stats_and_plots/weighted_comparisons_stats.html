<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>balance.stats_and_plots.weighted_comparisons_stats &#8212; balance  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=fb9458d3" />
    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">balance  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../balance.html" accesskey="U">balance</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">balance.stats_and_plots.weighted_comparisons_stats</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for balance.stats_and_plots.weighted_comparisons_stats</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) Meta Platforms, Inc. and affiliates.</span>
<span class="c1">#</span>
<span class="c1"># This source code is licensed under the MIT license found in the</span>
<span class="c1"># LICENSE file in the root directory of this source tree.</span>

<span class="c1"># pyre-strict</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Literal</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">balance.stats_and_plots.weighted_stats</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">descriptive_stats</span><span class="p">,</span>
    <span class="n">weighted_mean</span><span class="p">,</span>
    <span class="n">weighted_var</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">balance.stats_and_plots.weights_stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">_check_weights_are_valid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">balance.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">_safe_groupby_apply</span><span class="p">,</span> <span class="n">_safe_replace_and_infer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="kn">import</span> <span class="n">CategoricalDtype</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">quad</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">gaussian_kde</span>

<span class="n">logger</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__package__</span><span class="p">)</span>

<span class="c1"># TODO: add?</span>
<span class="c1"># from scipy.stats import wasserstein_distance</span>

<span class="c1">##########################################</span>
<span class="c1"># Weighted comparisons - functions to compare one or two data sources with one or two sources of weights</span>
<span class="c1">##########################################</span>


<span class="c1"># TODO: fix the r_indicator function. The current implementation is broken since it</span>
<span class="c1">#       seems to wrongly estimate N.</span>
<span class="c1">#       This seems to attempt to reproduce equation 2.2.2, in page 5 in</span>
<span class="c1">#       &quot;Indicators for the representativeness of survey response&quot;</span>
<span class="c1">#       by Jelke Bethlehem, Fannie Cobben, and Barry Schouten</span>
<span class="c1">#       See pdf: https://www150.statcan.gc.ca/n1/en/pub/11-522-x/2008000/article/10976-eng.pdf?st=Zi4d4zld</span>
<span class="c1">#       From: https://www150.statcan.gc.ca/n1/pub/11-522-x/2008000/article/10976-eng.pdf</span>
<span class="c1"># def r_indicator(sample_p: np.float64, target_p: np.float64) -&gt; np.float64:</span>
<span class="c1">#     p = np.concatenate((sample_p, target_p))</span>
<span class="c1">#     N = len(sample_p) + len(target_p)</span>
<span class="c1">#     return 1 - 2 * np.sqrt(1 / (N - 1) * np.sum((p - np.mean(p)) ** 2))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_weights_per_covars_names</span><span class="p">(</span><span class="n">covar_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="c1"># TODO (p2): consider if to give weights that are proportional to the proportion of this covar in the population</span>
    <span class="c1">#           E.g.: if merging varios platforms, maybe if something like windows has very few users, it&#39;s impact on the ASMD</span>
    <span class="c1">#           should be smaller (similar to how kld works).</span>
    <span class="c1">#           The current function structure won&#39;t support it, and this would require some extra input (i.e.: baseline target pop proportion)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Figure out how much weight to give to each column name for ASMD averaging.</span>
<span class="sd">    This is meant for post-processing df produced from model_matrix that include</span>
<span class="sd">    one-hot categorical variables. This function helps to resolve the needed weight to add</span>
<span class="sd">    to columns after they are broken down by the one-hot encoding used in model_matrix.</span>
<span class="sd">    Each of these will count for 1/num_levels.</span>
<span class="sd">    It&#39;s OK to assume that variables with &#39;[]&#39; in the name are one-hot</span>
<span class="sd">    categoricals because model_matrix enforces it.</span>

<span class="sd">    Args:</span>
<span class="sd">        covar_names (List): A list with names of covariate.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: with two columns, one for weights and another for main_covar_names,</span>
<span class="sd">        with rows for each of the columns from &#39;covar_names&#39;</span>

<span class="sd">    Examples:</span>
<span class="sd">        ::</span>

<span class="sd">            asmd_df = pd.DataFrame(</span>
<span class="sd">            {</span>
<span class="sd">                &#39;age&#39;: 0.5,</span>
<span class="sd">                &#39;education[T.high_school]&#39;: 1,</span>
<span class="sd">                &#39;education[T.bachelor]&#39;: 1,</span>
<span class="sd">                &#39;education[T.masters]&#39;: 1,</span>
<span class="sd">                &#39;education[T.phd]&#39;: 1,</span>
<span class="sd">            }, index = (&#39;self&#39;, ))</span>

<span class="sd">            input = asmd_df.columns.values.tolist()</span>
<span class="sd">                # input</span>
<span class="sd">                # [&#39;age&#39;,</span>
<span class="sd">                #  &#39;education[T.high_school]&#39;,</span>
<span class="sd">                #  &#39;education[T. bachelor]&#39;,</span>
<span class="sd">                #  &#39;education[T. masters]&#39;,</span>
<span class="sd">                #  &#39;education[T. phd]&#39;]</span>

<span class="sd">            _weights_per_covars_names(input).to_dict()</span>
<span class="sd">                # Output:</span>
<span class="sd">                # {&#39;weight&#39;: {&#39;age&#39;: 1.0,</span>
<span class="sd">                #   &#39;education[T.high_school]&#39;: 0.25,</span>
<span class="sd">                #   &#39;education[T.bachelor]&#39;: 0.25,</span>
<span class="sd">                #   &#39;education[T.masters]&#39;: 0.25,</span>
<span class="sd">                #   &#39;education[T.phd]&#39;: 0.25},</span>
<span class="sd">                #  &#39;main_covar_names&#39;: {&#39;age&#39;: &#39;age&#39;,</span>
<span class="sd">                #   &#39;education[T.high_school]&#39;: &#39;education&#39;,</span>
<span class="sd">                #   &#39;education[T.bachelor]&#39;: &#39;education&#39;,</span>
<span class="sd">                #   &#39;education[T.masters]&#39;: &#39;education&#39;,</span>
<span class="sd">                #   &#39;education[T.phd]&#39;: &#39;education&#39;}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">columns_to_original_variable</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\[.*\]$&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">covar_names</span><span class="p">}</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">columns_to_original_variable</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">counts</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">columns_to_original_variable</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
        <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">_check_weights_are_valid</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>  <span class="c1"># verify nothing odd has occurred.</span>
    <span class="n">main_covar_names</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
        <span class="n">columns_to_original_variable</span><span class="p">,</span>
        <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span>
            <span class="s2">&quot;main_covar_names&quot;</span><span class="p">,</span>
        <span class="p">],</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">weights</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">main_covar_names</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_kl_divergence_discrete</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the KL divergence between two discrete probability mass functions.</span>

<span class="sd">    Args:</span>
<span class="sd">        p: 1D array-like, PMF of the sample distribution (must sum to 1).</span>
<span class="sd">        q: 1D array-like, PMF of the target distribution (must sum to 1).</span>
<span class="sd">        eps: Small constant to avoid ``log(0)`` or division by zero.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The KL divergence ``sum_i p[i] * log(p[i] / q[i])``.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If inputs are not 1D arrays, are empty, have different</span>
<span class="sd">            lengths, contain invalid values, or sum to zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both p and q must be 1D arrays.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">q</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input PMF arrays must not be empty.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">q</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input PMF arrays must have the same length.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">q</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;PMF arrays must not contain negative values.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;PMF arrays must not contain NaN or infinite values.&quot;</span><span class="p">)</span>

    <span class="n">p_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">q_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p_sum</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">q_sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;PMF arrays must not sum to zero.&quot;</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="n">p_sum</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">q</span> <span class="o">/</span> <span class="n">q_sum</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">kl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span> <span class="o">/</span> <span class="n">q</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">kl</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_kl_divergence_continuous_quad</span><span class="p">(</span>
    <span class="n">p_samples</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">q_samples</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">p_weights</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">q_weights</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate the KL divergence between two continuous distributions using KDEs</span>
<span class="sd">    integrated with adaptive quadrature.</span>

<span class="sd">    Args:</span>
<span class="sd">        p_samples: 1D array-like samples from the sample distribution.</span>
<span class="sd">        q_samples: 1D array-like samples from the target distribution.</span>
<span class="sd">        p_weights: Optional weights for ``p_samples``.</span>
<span class="sd">        q_weights: Optional weights for ``q_samples``.</span>
<span class="sd">        eps: Small constant to avoid evaluating ``log(0)`` or dividing by zero.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Estimated KL divergence ``âˆ« p(x) log(p(x) / q(x)) dx``.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If inputs are not valid 1D arrays, empty, or have</span>
<span class="sd">            insufficient samples.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_samples</span><span class="p">(</span>
        <span class="n">samples</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">samples</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> must be a 1D array.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">samples</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> must not be empty.&quot;</span><span class="p">)</span>
        <span class="n">weights_arr</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights_arr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">weights_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> weights must match the number of samples.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights_arr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">weights_arr</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> weights must sum to a positive value.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">samples</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> must contain at least two samples for KDE.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights_arr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">weights_arr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> weights must be non-negative.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples</span><span class="p">,</span> <span class="n">weights_arr</span>

    <span class="n">p_samples</span><span class="p">,</span> <span class="n">p_weights</span> <span class="o">=</span> <span class="n">_validate_samples</span><span class="p">(</span><span class="n">p_samples</span><span class="p">,</span> <span class="n">p_weights</span><span class="p">,</span> <span class="s2">&quot;p_samples&quot;</span><span class="p">)</span>
    <span class="n">q_samples</span><span class="p">,</span> <span class="n">q_weights</span> <span class="o">=</span> <span class="n">_validate_samples</span><span class="p">(</span><span class="n">q_samples</span><span class="p">,</span> <span class="n">q_weights</span><span class="p">,</span> <span class="s2">&quot;q_samples&quot;</span><span class="p">)</span>

    <span class="n">kde_p</span><span class="p">:</span> <span class="n">gaussian_kde</span> <span class="o">=</span> <span class="n">gaussian_kde</span><span class="p">(</span><span class="n">p_samples</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">p_weights</span><span class="p">)</span>
    <span class="n">kde_q</span><span class="p">:</span> <span class="n">gaussian_kde</span> <span class="o">=</span> <span class="n">gaussian_kde</span><span class="p">(</span><span class="n">q_samples</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">q_weights</span><span class="p">)</span>

    <span class="n">min_support</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">p_samples</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">q_samples</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    <span class="n">max_support</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">p_samples</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">q_samples</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">integrand</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">p_x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">kde_p</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">eps</span><span class="p">,</span> <span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">q_x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">kde_q</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">eps</span><span class="p">,</span> <span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">p_x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p_x</span> <span class="o">/</span> <span class="n">q_x</span><span class="p">))</span>

    <span class="n">kl</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">min_support</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_support</span><span class="p">),</span> <span class="n">limit</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">kl</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>


<span class="c1"># TODO: add memoization</span>
<div class="viewcode-block" id="asmd">
<a class="viewcode-back" href="../../../balance.stats_and_plots.weighted_comparisons_stats.html#balance.stats_and_plots.weighted_comparisons_stats.asmd">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">asmd</span><span class="p">(</span>
    <span class="n">sample_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">target_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">sample_weights</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">target_weights</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">std_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">,</span> <span class="s2">&quot;sample&quot;</span><span class="p">,</span> <span class="s2">&quot;pooled&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;target&quot;</span><span class="p">,</span>
    <span class="n">aggregate_by_main_covar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Absolute Standardized Mean Deviation (ASMD) between the columns of two DataFrames (or BalanceDFs).</span>
<span class="sd">    It uses weighted average and std for the calculations.</span>
<span class="sd">    This is the same as taking the absolute value of Cohen&#39;s d statistic,</span>
<span class="sd">    with a specific choice of the standard deviation (std).</span>

<span class="sd">    https://en.wikipedia.org/wiki/Effect_size#Cohen&#39;s_d</span>

<span class="sd">    As opposed to Cohen&#39;s d, the current asmd implementation has several options of std calculation,</span>
<span class="sd">    see the arguments section for details.</span>

<span class="sd">    Unlike in R package {cobalt}, in the current implementation of asmd:</span>
<span class="sd">    - the absolute value is taken</span>
<span class="sd">    - un-represented levels of categorical variables are treated as missing,</span>
<span class="sd">      not as 0.</span>
<span class="sd">    - differences for categorical variables are also weighted by default</span>

<span class="sd">    The function omits columns that starts with the name &quot;_is_na_&quot;</span>

<span class="sd">    If column names of sample_df and target_df are different, it will only calculate asmd for</span>
<span class="sd">    the overlapping columns. The rest will be np.nan.</span>
<span class="sd">    The mean(asmd) will be calculated while treating the nan values as 0s.</span>

<span class="sd">    Args:</span>
<span class="sd">        sample_df (pd.DataFrame): source group of the asmd comparison</span>
<span class="sd">        target_df (pd.DataFrame): target group of the asmd comparison.</span>
<span class="sd">            The column names should be the same as the ones from sample_df.</span>
<span class="sd">        sample_weights (Union[ List, pd.Series, np.ndarray, ], optional): weights to use.</span>
<span class="sd">            The default is None.</span>
<span class="sd">            If no weights are passed (None), it will use an array of 1s.</span>
<span class="sd">        target_weights (Union[ List, pd.Series, np.ndarray, ], optional): weights to use.</span>
<span class="sd">            The default is None.</span>
<span class="sd">            If no weights are passed (None), it will use an array of 1s.</span>
<span class="sd">        std_type (Literal[&quot;target&quot;, &quot;sample&quot;, &quot;pooled&quot;], optional):</span>
<span class="sd">            How the standard deviation should be calculated.</span>
<span class="sd">            The options are: &quot;target&quot;, &quot;sample&quot; and &quot;pooled&quot;. Defaults to &quot;target&quot;.</span>
<span class="sd">            &quot;target&quot; means we use the std from the target population.</span>
<span class="sd">            &quot;sample&quot; means we use the std from the sample population.</span>
<span class="sd">            &quot;pooled&quot; means we use the simple arithmetic average of</span>
<span class="sd">                the variance from the sample and target population.</span>
<span class="sd">                We then take the square root of that value to get the pooled std.</span>
<span class="sd">                Notice that this is done while giving the same weight to both sources.</span>
<span class="sd">                I.e.: there is NO over/under weighting sample or target based on their</span>
<span class="sd">                respective sample sizes (in contrast to how pooled sd is calculated in</span>
<span class="sd">                Cohen&#39;s d statistic).</span>
<span class="sd">        aggregate_by_main_covar (bool):</span>
<span class="sd">            If to use :func:`_aggregate_statistic_by_main_covar` to aggregate (average) the asmd based on variable name.</span>
<span class="sd">            Default is False.</span>
<span class="sd">    Returns:</span>
<span class="sd">        pd.Series: a Series indexed on the names of the columns in the input DataFrames.</span>
<span class="sd">        The values (of type np.float64) are of the ASMD calculation.</span>
<span class="sd">        The last element is &#39;mean(asmd)&#39;, which is the average of the calculated ASMD values.</span>

<span class="sd">    Examples:</span>
<span class="sd">        ::</span>

<span class="sd">            import numpy as np</span>
<span class="sd">            import pandas as pd</span>
<span class="sd">            from balance.stats_and_plots import weighted_comparisons_stats</span>

<span class="sd">            a1 = pd.Series((1, 2))</span>
<span class="sd">            b1 = pd.Series((-1, 1))</span>
<span class="sd">            a2 = pd.Series((3, 4))</span>
<span class="sd">            b2 = pd.Series((-2, 2))</span>
<span class="sd">            w1 = pd.Series((1, 1))</span>
<span class="sd">            w2 = w1</span>

<span class="sd">            r = weighted_comparisons_stats.asmd(</span>
<span class="sd">                        pd.DataFrame({&quot;a&quot;: a1, &quot;b&quot;: b1}),</span>
<span class="sd">                        pd.DataFrame({&quot;a&quot;: a2, &quot;b&quot;: b2}),</span>
<span class="sd">                        w1,</span>
<span class="sd">                        w2,</span>
<span class="sd">                    )</span>

<span class="sd">            exp_a = np.abs(a1.mean() - a2.mean()) / a2.std()</span>
<span class="sd">            exp_b = np.abs(b1.mean() - b2.mean()) / b2.std()</span>
<span class="sd">            print(r)</span>
<span class="sd">            print(exp_a)</span>
<span class="sd">            print(exp_b)</span>

<span class="sd">            # output:</span>
<span class="sd">            # {&#39;a&#39;: 2.82842712474619, &#39;b&#39;: 0.0, &#39;mean(asmd)&#39;: 1.414213562373095}</span>
<span class="sd">            # 2.82842712474619</span>
<span class="sd">            # 0.0</span>



<span class="sd">            a1 = pd.Series((1, 2))</span>
<span class="sd">            b1_A = pd.Series((1, 3))</span>
<span class="sd">            b1_B = pd.Series((-1, -3))</span>
<span class="sd">            a2 = pd.Series((3, 4))</span>
<span class="sd">            b2_A = pd.Series((2, 3))</span>
<span class="sd">            b2_B = pd.Series((-2, -3))</span>
<span class="sd">            w1 = pd.Series((1, 1))</span>
<span class="sd">            w2 = w1</span>

<span class="sd">            r = weighted_comparisons_stats.asmd(</span>
<span class="sd">                pd.DataFrame({&quot;a&quot;: a1, &quot;b[A]&quot;: b1_A, &quot;b[B]&quot;: b1_B}),</span>
<span class="sd">                pd.DataFrame({&quot;a&quot;: a2, &quot;b[A]&quot;: b2_A, &quot;b[B]&quot;: b2_B}),</span>
<span class="sd">                w1,</span>
<span class="sd">                w2,</span>
<span class="sd">            ).to_dict()</span>

<span class="sd">            print(r)</span>
<span class="sd">            # {&#39;a&#39;: 2.82842712474619, &#39;b[A]&#39;: 0.7071067811865475, &#39;b[B]&#39;: 0.7071067811865475, &#39;mean(asmd)&#39;: 1.7677669529663689}</span>

<span class="sd">            # Check that using aggregate_by_main_covar works</span>
<span class="sd">            r = weighted_comparisons_stats.asmd(</span>
<span class="sd">                pd.DataFrame({&quot;a&quot;: a1, &quot;b[A]&quot;: b1_A, &quot;b[B]&quot;: b1_B}),</span>
<span class="sd">                pd.DataFrame({&quot;a&quot;: a2, &quot;b[A]&quot;: b2_A, &quot;b[B]&quot;: b2_B}),</span>
<span class="sd">                w1,</span>
<span class="sd">                w2,</span>
<span class="sd">                &quot;target&quot;,</span>
<span class="sd">                True,</span>
<span class="sd">            ).to_dict()</span>

<span class="sd">            print(r)</span>
<span class="sd">            # {&#39;a&#39;: 2.82842712474619, &#39;b&#39;: 0.7071067811865475, &#39;mean(asmd)&#39;: 1.7677669529663689}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sample_df must be pd.DataFrame, is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sample_df</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;target_df must be pd.DataFrame, is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">target_df</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">possible_std_type</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;sample&quot;</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">,</span> <span class="s2">&quot;pooled&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">std_type</span> <span class="ow">in</span> <span class="n">possible_std_type</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;std_type must be in </span><span class="si">{</span><span class="n">possible_std_type</span><span class="si">}</span><span class="s2">, is </span><span class="si">{</span><span class="n">std_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sample_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">!=</span> <span class="n">target_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            sample_df and target_df must have the same column names.</span>
<span class="s2">            sample_df column names: </span><span class="si">{</span><span class="n">sample_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span>
<span class="s2">            target_df column names: </span><span class="si">{</span><span class="n">target_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
        <span class="p">)</span>

    <span class="n">sample_mean</span> <span class="o">=</span> <span class="n">descriptive_stats</span><span class="p">(</span><span class="n">sample_df</span><span class="p">,</span> <span class="n">sample_weights</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">)</span>
    <span class="n">target_mean</span> <span class="o">=</span> <span class="n">descriptive_stats</span><span class="p">(</span><span class="n">target_df</span><span class="p">,</span> <span class="n">target_weights</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">std_type</span> <span class="o">==</span> <span class="s2">&quot;sample&quot;</span><span class="p">:</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">descriptive_stats</span><span class="p">(</span><span class="n">sample_df</span><span class="p">,</span> <span class="n">sample_weights</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">std_type</span> <span class="o">==</span> <span class="s2">&quot;target&quot;</span><span class="p">:</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">descriptive_stats</span><span class="p">(</span><span class="n">target_df</span><span class="p">,</span> <span class="n">target_weights</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">std_type</span> <span class="o">==</span> <span class="s2">&quot;pooled&quot;</span><span class="p">:</span>
        <span class="n">target_std</span> <span class="o">=</span> <span class="n">descriptive_stats</span><span class="p">(</span><span class="n">target_df</span><span class="p">,</span> <span class="n">target_weights</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">)</span>
        <span class="n">sample_std</span> <span class="o">=</span> <span class="n">descriptive_stats</span><span class="p">(</span><span class="n">sample_df</span><span class="p">,</span> <span class="n">sample_weights</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">)</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(((</span><span class="n">sample_std</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">target_std</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">out</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sample_mean</span> <span class="o">-</span> <span class="n">target_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">std</span>  <span class="c1"># pyre-ignore[61]: std is always defined</span>

    <span class="c1">#  Remove na indicator columns; it&#39;s OK to assume that these columns are</span>
    <span class="c1">#  indicators because add_na_indicator enforces it</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_is_na_&quot;</span><span class="p">))]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">_safe_replace_and_infer</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="c1"># TODO (p2): verify that df column names are unique (otherwise throw an exception).</span>
    <span class="c1">#            it should probably be upstream during in the Sample creation process.</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">_weights_per_covars_names</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())[</span>
        <span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span>
    <span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">out</span><span class="p">,</span> <span class="n">weights</span><span class="p">))</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">weighted_mean</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">])</span>
    <span class="n">out</span><span class="p">[</span><span class="s2">&quot;mean(asmd)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">out</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">aggregate_by_main_covar</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">_aggregate_statistic_by_main_covar</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="kld">
<a class="viewcode-back" href="../../../balance.stats_and_plots.weighted_comparisons_stats.html#balance.stats_and_plots.weighted_comparisons_stats.kld">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">kld</span><span class="p">(</span>
    <span class="n">sample_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">target_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">sample_weights</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">target_weights</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">aggregate_by_main_covar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Kullback-Leibler divergence (KLD) between the columns of two DataFrames.</span>

<span class="sd">    Numeric columns are compared using weighted kernel density estimates integrated</span>
<span class="sd">    via adaptive quadrature. Categorical (including binary/one-hot encoded)</span>
<span class="sd">    columns are treated as general discrete distributions based on their weighted</span>
<span class="sd">    empirical probability mass functions. Each column&#39;s contribution is aggregated</span>
<span class="sd">    into ``mean(kld)`` using the same weighting scheme as ASMD.</span>

<span class="sd">    The function omits columns that start with the name &quot;_is_na_&quot;.</span>

<span class="sd">    If column names of sample_df and target_df are different, it will only calculate KLD for</span>
<span class="sd">    the overlapping columns (using outer join with 0 fill for missing columns).</span>
<span class="sd">    The mean(kld) will be calculated using weighted averaging based on covariate structure.</span>

<span class="sd">    Args:</span>
<span class="sd">        sample_df (pd.DataFrame): source group of the KLD comparison.</span>
<span class="sd">        target_df (pd.DataFrame): target group of the KLD comparison.</span>
<span class="sd">            The column names should be the same as the ones from sample_df.</span>
<span class="sd">        sample_weights (Union[List, pd.Series, np.ndarray], optional): weights to use.</span>
<span class="sd">            The default is None. If no weights are passed (None), it will use an array</span>
<span class="sd">            of 1s.</span>
<span class="sd">        target_weights (Union[List, pd.Series, np.ndarray], optional): weights to use.</span>
<span class="sd">            The default is None. If no weights are passed (None), it will use an array</span>
<span class="sd">            of 1s.</span>
<span class="sd">        aggregate_by_main_covar (bool):</span>
<span class="sd">            If to use :func:`_aggregate_statistic_by_main_covar` to aggregate (average) the KLD based on variable name.</span>
<span class="sd">            Default is False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.Series: a Series indexed on the names of the columns in the input DataFrames.</span>
<span class="sd">            The values (of type np.float64) are of the KLD calculation.</span>
<span class="sd">            The last element is &#39;mean(kld)&#39;, which is the weighted average of the calculated KLD values.</span>

<span class="sd">    Examples:</span>
<span class="sd">        ::</span>

<span class="sd">            import pandas as pd</span>
<span class="sd">            from balance.stats_and_plots import weighted_comparisons_stats</span>

<span class="sd">            # Example with categorical data showing clear distributional differences</span>
<span class="sd">            sample_df = pd.DataFrame({</span>
<span class="sd">                &#39;category&#39;: [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;],</span>
<span class="sd">            })</span>
<span class="sd">            target_df = pd.DataFrame({</span>
<span class="sd">                &#39;category&#39;: [&#39;A&#39;, &#39;B&#39;, &#39;B&#39;, &#39;C&#39;],</span>
<span class="sd">            })</span>

<span class="sd">            # Calculate KLD between the two categorical distributions</span>
<span class="sd">            # Sample has: 50% A, 25% B, 25% C</span>
<span class="sd">            # Target has: 25% A, 50% B, 25% C</span>
<span class="sd">            kld_result = weighted_comparisons_stats.kld(sample_df, target_df)</span>
<span class="sd">            print(kld_result.round(6))</span>
<span class="sd">            # category[A]    0.143841</span>
<span class="sd">            # category[B]    0.130812</span>
<span class="sd">            # category[C]    0.000000</span>
<span class="sd">            # mean(kld)      0.091551</span>
<span class="sd">            # dtype: float64</span>

<span class="sd">            # Example with aggregation by main covariate name</span>
<span class="sd">            # This aggregates all category levels into a single KLD value</span>
<span class="sd">            kld_aggregated = weighted_comparisons_stats.kld(</span>
<span class="sd">                sample_df,</span>
<span class="sd">                target_df,</span>
<span class="sd">                aggregate_by_main_covar=True</span>
<span class="sd">            )</span>
<span class="sd">            print(kld_aggregated.round(6))</span>
<span class="sd">            # category      0.091551</span>
<span class="sd">            # mean(kld)     0.091551</span>
<span class="sd">            # dtype: float64</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sample_df must be pd.DataFrame, is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sample_df</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;target_df must be pd.DataFrame, is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">target_df</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sample_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">!=</span> <span class="n">target_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            sample_df and target_df must have the same column names.</span>
<span class="s2">            sample_df column names: </span><span class="si">{</span><span class="n">sample_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span>
<span class="s2">            target_df column names: </span><span class="si">{</span><span class="n">target_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
        <span class="p">)</span>

    <span class="n">sample_df</span><span class="p">,</span> <span class="n">target_df</span> <span class="o">=</span> <span class="n">sample_df</span><span class="o">.</span><span class="n">align</span><span class="p">(</span>
        <span class="n">target_df</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>

    <span class="n">sample_weights_arr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sample_weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sample_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sample_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">target_weights_arr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">target_weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">target_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">target_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_is_binary</span><span class="p">(</span><span class="n">series</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">uniques</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">dropna</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniques</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span><span class="n">uniques</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">})</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_extract_series_and_weights</span><span class="p">(</span>
        <span class="n">series</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">series</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Weights must match the number of observations.&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">series</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">weights</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_weighted_pmf</span><span class="p">(</span><span class="n">series</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">series</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">weights</span><span class="p">})</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">notna</span><span class="p">()]</span>
        <span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">grouped</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">total</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;PMF weights must sum to a positive value.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grouped</span> <span class="o">/</span> <span class="n">total</span>

    <span class="n">out</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">sample_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_is_na_&quot;</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="n">sample_series</span><span class="p">,</span> <span class="n">sample_w</span> <span class="o">=</span> <span class="n">_extract_series_and_weights</span><span class="p">(</span>
            <span class="n">sample_df</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">sample_weights_arr</span>
        <span class="p">)</span>
        <span class="n">target_series</span><span class="p">,</span> <span class="n">target_w</span> <span class="o">=</span> <span class="n">_extract_series_and_weights</span><span class="p">(</span>
            <span class="n">target_df</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">target_weights_arr</span>
        <span class="p">)</span>

        <span class="n">is_discrete</span> <span class="o">=</span> <span class="n">_is_binary</span><span class="p">(</span><span class="n">sample_series</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_binary</span><span class="p">(</span><span class="n">target_series</span><span class="p">)</span>
        <span class="n">is_discrete</span> <span class="o">=</span> <span class="n">is_discrete</span> <span class="ow">or</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_object_dtype</span><span class="p">(</span><span class="n">sample_series</span><span class="p">)</span>
        <span class="n">is_discrete</span> <span class="o">=</span> <span class="n">is_discrete</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_series</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">CategoricalDtype</span><span class="p">)</span>
        <span class="n">is_discrete</span> <span class="o">=</span> <span class="n">is_discrete</span> <span class="ow">or</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">sample_series</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_discrete</span><span class="p">:</span>
            <span class="n">sample_pmf</span> <span class="o">=</span> <span class="n">_weighted_pmf</span><span class="p">(</span><span class="n">sample_series</span><span class="p">,</span> <span class="n">sample_w</span><span class="p">)</span>
            <span class="n">target_pmf</span> <span class="o">=</span> <span class="n">_weighted_pmf</span><span class="p">(</span><span class="n">target_series</span><span class="p">,</span> <span class="n">target_w</span><span class="p">)</span>
            <span class="n">pmfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span><span class="n">sample_pmf</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;sample&quot;</span><span class="p">),</span> <span class="n">target_pmf</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;target&quot;</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">_kl_divergence_discrete</span><span class="p">(</span>
                <span class="n">pmfs</span><span class="p">[</span><span class="s2">&quot;sample&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="n">pmfs</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample_vals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">sample_series</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
            <span class="n">target_vals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">target_series</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
            <span class="n">sample_w_numeric</span> <span class="o">=</span> <span class="n">sample_w</span><span class="p">[</span><span class="n">sample_series</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">sample_vals</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span>
            <span class="n">target_w_numeric</span> <span class="o">=</span> <span class="n">target_w</span><span class="p">[</span><span class="n">target_series</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">target_vals</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span>
            <span class="n">out</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">_kl_divergence_continuous_quad</span><span class="p">(</span>
                <span class="n">sample_vals</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
                <span class="n">target_vals</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
                <span class="n">sample_w_numeric</span> <span class="k">if</span> <span class="n">sample_w_numeric</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">target_w_numeric</span> <span class="k">if</span> <span class="n">target_w_numeric</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">_safe_replace_and_infer</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">out</span><span class="p">]))</span>

    <span class="n">weights</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">_weights_per_covars_names</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span>
        <span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
        <span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">out</span><span class="p">,</span> <span class="n">weights</span><span class="p">))</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">weighted_mean</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">])</span>
    <span class="n">out</span><span class="p">[</span><span class="s2">&quot;mean(kld)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">out</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">aggregate_by_main_covar</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">_aggregate_statistic_by_main_covar</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_aggregate_statistic_by_main_covar</span><span class="p">(</span><span class="n">statistic_series</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function helps to aggregate statistics (e.g., ASMD, KLD), which are broken down per level for a category variable,</span>
<span class="sd">    into one value per covariate.</span>
<span class="sd">    This is useful since it allows us to get high level view of features such as country, locale, etc.</span>
<span class="sd">    It also allows us to filter out variables (such as is_today) before the overall averaging of the ASMD.</span>

<span class="sd">    Args:</span>
<span class="sd">        statistic_series (pd.Series): a value for each covariate. Covariate name are in the index, the values are the asmd values.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.Series: If statistic_series had several items broken by one-hot encoding,</span>
<span class="sd">            then they would be averaged (with equal weight to each).</span>

<span class="sd">    Examples:</span>
<span class="sd">        ::</span>

<span class="sd">            from balance.stats_and_plots.weighted_comparisons_stats import _aggregate_statistic_by_main_covar</span>

<span class="sd">            statistic_series = pd.Series(</span>
<span class="sd">            {</span>
<span class="sd">                &#39;age&#39;: 0.5,</span>
<span class="sd">                &#39;education[T.high_school]&#39;: 1,</span>
<span class="sd">                &#39;education[T.bachelor]&#39;: 2,</span>
<span class="sd">                &#39;education[T.masters]&#39;: 3,</span>
<span class="sd">                &#39;education[T.phd]&#39;: 4,</span>
<span class="sd">            })</span>

<span class="sd">            _aggregate_statistic_by_main_covar(statistic_series).to_dict()</span>

<span class="sd">            # output:</span>
<span class="sd">            # {&#39;age&#39;: 0.5, &#39;education&#39;: 2.5}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">_weights_per_covars_names</span><span class="p">(</span><span class="n">statistic_series</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

    <span class="c1"># turn things into DataFrame to make it easy to aggregate.</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">statistic_series</span><span class="p">,</span> <span class="n">weights</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Define the apply function for calculating weighted means</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_weighted_mean</span><span class="p">(</span><span class="n">group_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">group_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># First column contains the ASMD values</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">group_data</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">values</span> <span class="o">*</span> <span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># Use _safe_groupby_apply to handle pandas compatibility</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">_safe_groupby_apply</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;main_covar_names&quot;</span><span class="p">,</span> <span class="n">calculate_weighted_mean</span><span class="p">)</span>
    <span class="n">out</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">out</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">out</span>


<span class="c1"># TODO: (p2) sample_before and sample_after are redundant, the moment weights of</span>
<span class="c1">#           before and after are supplied directly.</span>
<span class="c1">#           In the future, we can either omit sample_after, or change the names to</span>
<span class="c1">#           reflect a support a comparison of two panels to some target populations.</span>
<div class="viewcode-block" id="asmd_improvement">
<a class="viewcode-back" href="../../../balance.stats_and_plots.weighted_comparisons_stats.html#balance.stats_and_plots.weighted_comparisons_stats.asmd_improvement">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">asmd_improvement</span><span class="p">(</span>
    <span class="n">sample_before</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">sample_after</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">sample_before_weights</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sample_after_weights</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">target_weights</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculates the improvement in mean(asmd) from before to after applying some weight adjustment.</span>

<span class="sd">    Args:</span>
<span class="sd">        sample_before (pd.DataFrame): DataFrame of the sample before adjustments.</span>
<span class="sd">        sample_after (pd.DataFrame): DataFrame of the sample after adjustments</span>
<span class="sd">            (should be identical to sample_before. But could be used to compare two populations).</span>
<span class="sd">        target (pd.DataFrame): DataFrame of the target population.</span>
<span class="sd">        sample_before_weights (Union[ List, pd.Series, np.ndarray, ], optional): Weights before adjustments (i.e.: design weights). Defaults to None.</span>
<span class="sd">        sample_after_weights (Union[ List, pd.Series, np.ndarray, ], optional): Weights after some adjustment. Defaults to None.</span>
<span class="sd">        target_weights (Union[ List, pd.Series, np.ndarray, ], optional): Design weights of the target population. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.float64: The improvement is taking the (before_mean_asmd-after_mean_asmd)/before_mean_asmd.</span>
<span class="sd">        The asmd is calculated using :func:`asmd`.</span>
<span class="sd">        Returns 0.0 when asmd_mean_before is zero or very close to zero (&lt; 1e-10).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">asmd_mean_before</span> <span class="o">=</span> <span class="n">asmd</span><span class="p">(</span>
        <span class="n">sample_before</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sample_before_weights</span><span class="p">,</span> <span class="n">target_weights</span>
    <span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;mean(asmd)&quot;</span><span class="p">]</span>
    <span class="n">asmd_mean_after</span> <span class="o">=</span> <span class="n">asmd</span><span class="p">(</span>
        <span class="n">sample_after</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sample_after_weights</span><span class="p">,</span> <span class="n">target_weights</span>
    <span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;mean(asmd)&quot;</span><span class="p">]</span>

    <span class="c1"># Avoid division by zero when asmd_mean_before is zero or very close to zero</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">asmd_mean_before</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">asmd_mean_before</span> <span class="o">-</span> <span class="n">asmd_mean_after</span><span class="p">)</span> <span class="o">/</span> <span class="n">asmd_mean_before</span></div>



<div class="viewcode-block" id="outcome_variance_ratio">
<a class="viewcode-back" href="../../../balance.stats_and_plots.weighted_comparisons_stats.html#balance.stats_and_plots.weighted_comparisons_stats.outcome_variance_ratio">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">outcome_variance_ratio</span><span class="p">(</span>
    <span class="n">df_numerator</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">df_denominator</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">w_numerator</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">w_denominator</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate ratio of weighted variances of two DataFrames</span>

<span class="sd">    Directly calculating the empirical ratio of variance of the outcomes before and after weighting.</span>
<span class="sd">    Notice that this is different than design effect.</span>
<span class="sd">    The Deff estimates the ratio of variances of the weighted means, while this function calculates the ratio</span>
<span class="sd">    of empirical weighted variance of the data.</span>

<span class="sd">    Args:</span>
<span class="sd">        df_numerator (pd.DataFrame): df_numerator</span>
<span class="sd">        df_denominator (pd.DataFrame): df_denominator</span>
<span class="sd">        w_numerator (Union[ List, pd.Series, np.ndarray, None, ], optional): w_numerator. Defaults to None.</span>
<span class="sd">        w_denominator (Union[ List, pd.Series, np.ndarray, None, ], optional): w_denominator. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.Series: (np.float64) A series of calculated ratio of variances for each outcome.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numerator_w_var</span> <span class="o">=</span> <span class="n">weighted_var</span><span class="p">(</span><span class="n">df_numerator</span><span class="p">,</span> <span class="n">w_numerator</span><span class="p">)</span>
    <span class="n">denominator_w_var</span> <span class="o">=</span> <span class="n">weighted_var</span><span class="p">(</span><span class="n">df_denominator</span><span class="p">,</span> <span class="n">w_denominator</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numerator_w_var</span> <span class="o">/</span> <span class="n">denominator_w_var</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">balance  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../balance.html" >balance</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">balance.stats_and_plots.weighted_comparisons_stats</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    </div>
  </body>
</html>